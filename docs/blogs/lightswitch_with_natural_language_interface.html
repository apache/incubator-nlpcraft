---
title: Light Switch With Natural Language Interface
author: Aaron Radzinksi
avatar_url: images/lion.jpg
publish_date: Jul 16, 2019
flag-ico: images/us-flag-128x128.png
layout: blog
---

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<section>
    <div class="blog-header">
        <div class="blog-title">{{page.title}}</div>
        <div class="blog-sub-title">
            <img class="avatar-img" src="{{ page.avatar_url | relative_url}}">
            <span class="blog-author text-nowrap">{{ page.author }}</span>
            <img class="flag-img" src="{{ page.flag-ico | relative_url}}">
            <span class="text-nowrap blog-date">{{ page.publish_date }}</span>
        </div>
    </div>
    <p>
        In this blog I‚Äôll show how to build a natural language interface for a typical home light
        switch so that you could turn the lights on and off with simple commands like <code>"Turn off all the lights,
        please"</code> or <code>"Get the lights on in the kids bedroom."</code>
    </p>
    <p>
        We‚Äôll concentrate on Natural Language Interface (NLI) part, and I‚Äôll leave speech-to-text and
        the actual light controlling outside of the scope of this short blog. You can easily add speech-to-text
        with <a target=_ href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API">WebSpeech</a>,
        if necessary, while <a target=_ href="https://www.arduino.cc">Arduino</a>/<a target=_ href="https://developer.apple.com/homekit">HomeKit</a>
        can provide simple API to control the lights in your house.
    </p>
    <p>
        For our implementation we‚Äôll use NLPCraft and Scala language (NLPCraft also supports any JVM-based language
        of your choice like Java, Groovy or Kotlin). NLPCraft is a <a href="/legal.html">free open source</a>
        project that allows you to
        quickly build domain-specific natural language interface to any device or software. It uses modern semantic
        modelling and deterministic intent-based matching of the user input instead of the traditional
        computational linguistics (i.e. neural networks). Because of that, it does not require any pre-existing
        domain corpora or a lengthy model training and development.
    </p>
    <p>
        Most of the work, when using NLPCraft, is around building a semantic model for your specific domain.
        A model defines a set of named entities (user-defined or 3rd party from
        <a target=_ href="https://spacy.io">spaCy</a>,
        <a target=_ href="https://opennlp.apache.org">OpenNLP</a>,
        <a target=_ href="https://stanfordnlp.github.io">Stanford CoreNLP</a> or
        <a target=_ href="https://cloud.google.com/natural-language">Google Natural Language</a>) that should be detected in the user. NLPCraft
        also provides an advanced intent matching which we‚Äôll use later in this example.
    </p>
    <p>
        Let‚Äôs think about our task at hand of supporting a free-form natural language interface for a typical light switch.
        Here‚Äôs a sample of commands that we‚Äôd like to support:
    </p>
    <ul>
        <li><code>Turn the lights off in the entire house</code></li>
        <li><code>Switch on the illumination in the master bedroom closet</code></li>
        <li><code>Get the lights on</code></li>
        <li><code>Please, put the light out in the upstairs bedroom</code></li>
        <li><code>Set the lights on in the entire house</code></li>
        <li><code>Turn the lights off in the guest bedroom</code></li>
        <li><code>Could you please switch off all the lights?</code></li>
        <li><code>Dial off illumination on the 2nd floor</code></li>
        <li><code>Please, no lights!</code></li>
        <li><code>Kill off all the lights now!</code></li>
        <li><code>No lights in the bedroom, please</code></li>
    </ul>
    <p>
        By looking at these examples you can easily spot three distinct entities that we need to be able to detect
        in the user input that we‚Äôll later use in our intents:
    </p>
    <ul>
        <li>An action to turn the light on</li>
        <li>An action to turn the light off</li>
        <li>Location of the light</li>
    </ul>
    <p>
        Here‚Äôs the <a target=_ href="https://gist.github.com/aradzinski/0d2b46d68f3c9cf9cf5d0424a93222fa">declarative part</a>
        of the NLPCraft semantic model in YAML that defines these three entities:
    </p>
    <pre class="brush: js, highlight: [5, 14, 21, 29]">
id: "nlpcraft.lightswitch.ex"
name: "Light Switch Example Model"
version: "1.0"
description: "NLI-powered light switch example model."
macros:
  - name: "&lt;ACTION&gt;"
    macro: "{turn|switch|dial|control|let|set|get|put}"
  - name: "&lt;ENTIRE_OPT&gt;"
    macro: "{entire|full|whole|total|*}"
  - name: "&lt;LIGHT&gt;"
    macro: "{all|*} {it|them|light|illumination|lamp|lamplight}"
enabledBuiltInTokens: [] # Don't use any built-in tokens.
elements:
  - id: "ls:loc"
    description: "Location of lights."
    synonyms:
      - "&lt;ENTIRE_OPT&gt; {upstairs|downstairs|*} {kitchen|library|closet|garage|office|playroom|{dinning|laundry|play} room}"
      - "&lt;ENTIRE_OPT&gt; {upstairs|downstairs|*} {master|kid|children|child|guest|*} {bedroom|bathroom|washroom|storage} {closet|*}"
      - "&lt;ENTIRE_OPT&gt; {house|home|building|{1st|first} floor|{2nd|second} floor}"

  - id: "ls:on"
    groups:
      - "act"
    description: "Light switch ON action."
    synonyms:
      - "&lt;ACTION&gt; &lt;LIGHT&gt; on"
      - "&lt;ACTION&gt; on &lt;LIGHT&gt;"

  - id: "ls:off"
    groups:
      - "act"
    description: "Light switch OFF action."
    synonyms:
      - "&lt;ACTION&gt; &lt;LIGHT&gt; {off|out}"
      - "{&lt;ACTION&gt;|shut|kill|stop|eliminate} {off|out} &lt;LIGHT&gt;"
      - "no &lt;LIGHT&gt;"        
    </pre>
    <p>
        Besides some syntactical peculiarities this model definition is pretty self explanatory:
    </p>
    <ul>
        <li>
            Lines <b>14</b>, <b>21</b> and <b>29</b> define our three elements (i.e. named entities): <code>ls:loc</code>, <code>ls:on</code>
            and <code>ls:off</code>. Each element is defined through a macro-expanded set of synonyms.
        </li>
        <li>
            Line <b>5</b> provides a list of macros used later in elements definition.
        </li>
    </ul>
    <p>
        What is remarkable about this model is how productive and economical these few dozens of YAML lines are:
    </p>
    <div class="bq info">
        <p>
            <b>Over 100,000 Synonyms</b>
        </p>
        <p>
            When loaded by NLPCraft this model translates into > 100,000 different synonyms for each element ‚Äî which
            in traditional approach would have to be created manually.
        </p>
    </div>
    <p>
        NLPCraft is smart about synonyms processing: apart from basic normalization, tokenization, stemmatization,
        stopword elimination, etc. it performs advanced shuffling and weighted selection algorithm. You can also use
        PoS tags, regular expressions or user-defined predicates when defining semantic elements for more advanced
        detection use cases.
    </p>
    <p>
        Now that we have our declarative part of the model configuration we can finish the <a target=_ href="https://gist.github.com/aradzinski/79a53440e527ed7d065d56b79114becc">rest of the model</a>
        definition by providing the intent matching logic. Technically, NLPCraft model is just an implementation of
        <a target=_ href="https://nlpcraft.org/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> Java interface. We‚Äôll use convenient
        <a target=_ href="https://nlpcraft.org/apis/latest/org/nlpcraft/model/NCModelFileAdapter.html">NCModelFileAdapter</a> adapter to implement our model with
        above YAML-based configuration:
    </p>
    <pre class="brush: scala, highlight: [1, 2, 13]">
class LightSwitchModel extends NCModelFileAdapter("org/nlpcraft/examples/lightswitch/lightswitch_model.yaml") {
    @NCIntent("intent=act conv=false term(act)={groups @@ 'act'} term(loc)={id == 'ls:loc'}*")
    def onMatch(
        @NCIntentTerm("act") actTok: NCToken,
        @NCIntentTerm("loc") locToks: List[NCToken]
    ): NCResult = {
        val status = if (actTok.getId == "ls:on") "on" else "off"
        val locations = if (locToks.isEmpty) "entire house" else locToks.map(getOriginalText).mkString(", ")

        // Add HomeKit, Arduino or other integration here.

        // By default - just return a descriptive action string.
        NCResult.text(s"Lights '$status' in '${locations.toLowerCase}'.")
    }
}
    </pre>
    <p>
        Few comments:
    </p>
    <ul>
        <li>On line <b>1</b> we initialize the model from the external YAML-based configuration (that we discussed above).</li>
        <li>
            On line <b>2</b> we attached the intent to its <code>onMatch(‚Ä¶)</code> callback. Note that we use
            <a href="https://nlpcraft.org/apis/latest/org/nlpcraft/model/intent/NCIntent.html">NCIntent</a> Java
            annotation and intent DSL supported by NLPCraft. This intent will match any user input that
            has the following entities:
            <ul>
                <li>exactly one action (i.e. any entity belonging to the group <code>"act‚Äù</code>) and</li>
                <li>zero or more lights locations.</li>
            </ul>
        </li>
        <li>
            Detected entities will be mapped to the callback method parameters via <a href="https://nlpcraft.org/apis/latest/org/nlpcraft/model/intent/NCIntentTerm.html    ">NCIntentTerm</a> annotations
            when the intent is matched and the callback is called.
        </li>
        <li>
            Callback implementation simply returns the status of the lights (see line <b>13</b>). You can add
            your Arduino, HomeKit, etc. integration at this point.
        </li>
    </ul>
    <p>
        And we are done üéâ
    </p>
    <p>
        Compile and deploy the model into the data probe, start the REST server (more details on this here) ‚Äî and
        you have model ready to accept REST call and start controlling the lights with the natural language.
    </p>
    <div class="blog-h1">Testing</div>
    <p>
        Although you can simply use <a href="https://nlpcraft.org/getting-started.html">any REST tool</a> to send input into the model ‚Äî we‚Äôll use built-in JUnit 5
        compatible test framework to get a bit more automation.
    </p>
    <p>
        Create <a href="https://gist.github.com/aradzinski/4d3431dd38373d316e29f43a65ead650.js">LightSwitchTest.java</a> file with this code and run it:
    </p>
    <pre class="brush: java, highlight: [27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37]">
package org.nlpcraft.examples.lightswitch;

import org.junit.jupiter.api.*;
import org.nlpcraft.common.*;
import org.nlpcraft.model.tools.test.*;
import java.io.*;

import static org.junit.jupiter.api.Assertions.*;

class LightSwitchTest {
    private NCTestClient cli;

    @BeforeEach
    void setUp() throws NCException, IOException {
        cli = new NCTestClientBuilder().newBuilder().build();

        cli.open("nlpcraft.lightswitch.ex");
    }

    @AfterEach
    void tearDown() throws NCException, IOException {
        cli.close();
    }

    @Test
    void test() throws NCException, IOException {
        assertTrue(cli.ask("Turn the lights off in the entire house.").isOk());
        assertTrue(cli.ask("Switch on the illumination in the master bedroom closet.").isOk());
        assertTrue(cli.ask("Get the lights on.").isOk());
        assertTrue(cli.ask("Please, put the light out in the upstairs bedroom.").isOk());
        assertTrue(cli.ask("Set the lights on in the entire house.").isOk());
        assertTrue(cli.ask("Turn the lights off in the guest bedroom.").isOk());
        assertTrue(cli.ask("Could you please switch off all the lights?").isOk());
        assertTrue(cli.ask("Dial off illumination on the 2nd floor.").isOk());
        assertTrue(cli.ask("Please, no lights!").isOk());
        assertTrue(cli.ask("Kill off all the lights now!").isOk());
        assertTrue(cli.ask("No lights in the bedroom, please.").isOk());
    }
}
    </pre>
    <p>
        Note that we use the our original sentences in out test that we wanted to support in the beginning. You can
        look at the test output and verify that everything works as expected.
    </p>
    <p>
        Having an automated test allows you to quickly play with the model, make changes or iterate on your
        modifications without breaking something in the process.
    </p>
    <p>
        Go ahead and play with this mode: you can add Arduino integration or adopt the model <code>ls:loc</code>
        entity to your own home configuration; you can add some slang or quirky ways to operate your lights...
    </p>
</section>