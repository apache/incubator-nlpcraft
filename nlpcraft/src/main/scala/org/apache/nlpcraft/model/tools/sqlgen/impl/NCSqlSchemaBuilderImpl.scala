/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.nlpcraft.model.tools.sqlgen.impl

import java.util

import org.apache.nlpcraft.common.NCException
import org.apache.nlpcraft.model.NCModel
import org.apache.nlpcraft.model.tools.sqlgen._

import scala.collection.JavaConverters._
import scala.collection.Seq
import scala.compat.java8.OptionConverters._

/**
  * 
  */
object NCSqlSchemaBuilderImpl {
    /**
      *
      * @param cols
      * @param tbl
      * @param col
      * @return
      * @throws NCException
      */
    private def findSchemaColumn(cols: util.List[NCSqlColumn], tbl: String, col: String): NCSqlColumn =
        cols.asScala.find(_.getColumn == col).getOrElse(throw new NCException(s"Column not found: $tbl.$col"))
    
    /**
      * 
      * @param mdl
      * @return
      * @throws NCException
      */
    def makeSchema(mdl: NCModel): NCSqlSchema = {
        // Soft check that the model generated by 'sqlgen' tool.
        if (!mdl.metaOpt("sql:url").isPresent)
            throw new NCException("Model does not seem to be generated by 'NCSqlModelGenerator' utility.")
        
        val elems = mdl.getElements.asScala
        
        val tabCols =
            elems.filter(_.getGroups.contains("column")).map(p ⇒ {
                val col: NCSqlColumn =
                    NCSqlColumnImpl(
                        p.metax("sql:tablename"),
                        p.metax("sql:name"),
                        p.metax("sql:datatype"),
                        p.metax("sql:ispk"),
                        p.metax("sql:isnullable")
                    )
                
                col
            }).groupBy(_.getTable).map { case (tab, cols) ⇒ tab → cols }

        val defSorts = collection.mutable.HashMap.empty[NCSqlSort, String]

        var tables =
            elems.filter(_.getGroups.contains("table")).
                map(p ⇒ {
                    def x(l: util.List[String]): Seq[String] = if (l == null) Seq.empty else l.asScala

                    val tab: String = p.metax("sql:name")
                    val dfltSelect = x(p.metax("sql:defaultselect"))
                    val dfltSort = x(p.metax("sql:defaultsort"))
                    val extra = x(p.meta("sql:extratables"))
                    val defDateOpt: Option[String] = p.metaOpt("sql:defaultdate").asScala

                    val cols = tabCols(tab).toSeq.sortBy(p ⇒ (if (p.isPk) 0 else 1, p.getColumn)).asJava
                    
                    val table: NCSqlTableImpl = NCSqlTableImpl(
                        table = tab,
                        // TODO: columns should be list, but elements are set. How should we order them?
                        // TODO: Seems elements should be seq too in model.
                        columns = cols.asScala,
                        sorts = Seq.empty,
                        selects = dfltSelect,
                        extraTables = extra,
                        defaultDate = defDateOpt match {
                            case Some(defDate) ⇒
                                def error() = throw new NCException(s"Invalid default date declaration in: $defDate")

                                val pair = defDate.split("\\.")

                                if (pair.length != 2)
                                    error()

                                val tab = pair.head
                                val col = pair.last.toLowerCase

                                Some(tabCols.getOrElse(tab, error()).find(_.getColumn == col).getOrElse(error()))
                            case None ⇒ None
                        }
                    )

                    dfltSort.
                        foreach(s ⇒ {
                            def error() = throw new NCException(s"Invalid default sort declaration in: $s")

                            var pair = s.split("\\.")

                            val t =
                                pair.length match {
                                    case 1 ⇒
                                        pair = s.split("#")

                                        // By default, same table name.
                                        tab
                                    case 2 ⇒
                                        val t = pair.head

                                        pair = pair.last.split("#")

                                        t
                                    case  _ ⇒ error()
                                }

                            if (pair.length != 2)
                                error()

                            val col = pair.head
                            val asc = pair.last.toLowerCase

                            if (asc != "asc" && asc != "desc")
                                error()

                            defSorts += NCSqlSortImpl(findSchemaColumn(cols, t, col), asc == "asc") → t
                        })

                    table
                }).toSeq

        val defSortsByTab =
            defSorts.
                groupBy { case (_, table) ⇒ table }.
                map { case (table, seq) ⇒ table → seq.map { case (sort, _) ⇒ sort}.toSeq }

        tables = tables.map(t ⇒
            NCSqlTableImpl(
                table = t.table,
                columns = t.columns,
                sorts = defSortsByTab.getOrElse(t.table, Seq.empty),
                selects = t.selects,
                extraTables = t.extraTables,
                defaultDate = t.defaultDate
            )
        )

        val joinsMap = mdl.metax("sql:joins").asInstanceOf[util.List[util.Map[String, Object]]]
    
        val joins = joinsMap.asScala.map(_.asScala).map(m ⇒ {
            def mget[T](prop: String): T =
                m.get(prop) match {
                    case Some(v) ⇒ v.asInstanceOf[T]
                    case None ⇒ throw new NCException(s"Metadata property not found: $prop")
                }
            
            val join: NCSqlJoin = NCSqlJoinImpl(
                mget("fromtable").asInstanceOf[String],
                mget("totable").asInstanceOf[String],
                mget("fromcolumns").asInstanceOf[util.List[String]].asScala,
                mget("tocolumns").asInstanceOf[util.List[String]].asScala,
                NCSqlJoinType.valueOf(mget("jointype").asInstanceOf[String].toUpperCase())
            )
            
            join
        })
        
        NCSqlSchemaImpl(tables, joins)
    }
}
